---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: cnpg-disaster-recovery-check
spec:
  schedule: "*/15 * * * *"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      backoffLimit: 0
      template:
        spec:
          serviceAccountName: cnpg-disaster-recovery-check
          automountServiceAccountToken: true
          securityContext:
            runAsNonRoot: true
            runAsUser: 65534
            runAsGroup: 65534
            seccompProfile:
              type: RuntimeDefault
          restartPolicy: Never
          containers:
            - name: dr-check
              image: alpine/k8s:1.30.0
              imagePullPolicy: IfNotPresent
              securityContext:
                allowPrivilegeEscalation: false
                capabilities:
                  drop: ["ALL"]
              env:
                - name: NAMESPACE
                  valueFrom:
                    fieldRef:
                      fieldPath: metadata.namespace
                - name: TARGET_CLUSTER
                  value: cnpg-disaster-recovery
                - name: MAX_REPLAY_LAG_SECONDS
                  value: "900"
              command:
                - /bin/sh
                - -ceu
                - |
                  echo "[cnpg-disaster-recovery-check] starting"

                  kubectl -n "$NAMESPACE" wait --for=condition=Ready "cluster.postgresql.cnpg.io/$TARGET_CLUSTER" --timeout=15m

                  pod=$(kubectl -n "$NAMESPACE" get pods -l "cnpg.io/cluster=$TARGET_CLUSTER,cnpg.io/instanceRole=primary" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
                  if [ -z "$pod" ]; then
                    pod=$(kubectl -n "$NAMESPACE" get pods -l "cnpg.io/cluster=$TARGET_CLUSTER" -o jsonpath='{.items[0].metadata.name}')
                  fi
                  kubectl -n "$NAMESPACE" wait --for=condition=Ready "pod/$pod" --timeout=10m

                  out=$(kubectl -n "$NAMESPACE" exec "$pod" -- /bin/sh -ceu \
                    "psql -U postgres -d postgres -v ON_ERROR_STOP=1 -Atc \"\
                      SELECT pg_is_in_recovery();\
                      SELECT COALESCE(EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())), 0)::int;\
                      SELECT 1;\
                    \""
                  )

                  is_recovery=$(printf "%s\n" "$out" | sed -n '1p')
                  lag_seconds=$(printf "%s\n" "$out" | sed -n '2p')

                  if [ "$is_recovery" != "t" ]; then
                    echo "[cnpg-disaster-recovery-check] FAIL: not in recovery (pg_is_in_recovery=$is_recovery)"
                    exit 1
                  fi

                  case "$lag_seconds" in
                    ''|*[!0-9]*)
                      echo "[cnpg-disaster-recovery-check] FAIL: replay lag not an integer: '$lag_seconds'"
                      exit 1
                      ;;
                  esac

                  if [ "$lag_seconds" -gt "$MAX_REPLAY_LAG_SECONDS" ]; then
                    echo "[cnpg-disaster-recovery-check] FAIL: replay lag $lag_seconds""s exceeds $MAX_REPLAY_LAG_SECONDS""s"
                    exit 1
                  fi

                  echo "[cnpg-disaster-recovery-check] OK: replay_lag_seconds=$lag_seconds"
                  echo "[cnpg-disaster-recovery-check] done"
